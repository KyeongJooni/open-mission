## 오픈미션

### 개요

프리코스에서 배운 인사이트를 동아리 블로그 프로젝트에 적용하는 3가지 고난도 미션

| 미션 | 내용 | 상태 |
|------|------|------|
| 1 | 테스트 커버리지 90% 달성 | 완료 |
| 2 | 상태 분석 시각화 도구 | 완료 |
| 3 | 애니메이션/인터랙션 시스템 | 완료 |

### 개발 원칙

- Angular 커밋 컨벤션 준수
- JavaScript 스타일 가이드 적용

<br>

---

## 1. 테스트 커버리지 90% 달성

### 문제 정의

프리코스 3주 동안 핵심 학습 목표 중 하나는 **"단위 테스트를 통해 코드를 구조적으로 사고하는 것"**이었다. 그러나 현재 프로젝트의 테스트 커버리지는 약 5%에 불과했다.

테스트가 없는 코드는 수정할 때마다 "다른 곳이 깨지진 않을까?"라는 불안감을 동반한다. 특히 `blogContentParser`, `apiInstance`와 같은 핵심 모듈은 여러 컴포넌트에서 사용되므로, 한 곳의 수정이 전체에 영향을 미칠 수 있다.

**주요 문제점:**
- 코드 변경에 대한 자신감 부족
- API 실패, 토큰 만료, 경계값 등 예외 상황 처리 미흡
- 15라인 초과 함수 분리 시 기존 동작 유지 검증 불가
- 비즈니스/UI 로직이 섞여 있어 테스트하기 어려움

### 해결 접근 방식

**테스트를 통한 코드 품질 향상**

- **코드 변경에 대한 자신감**: 테스트가 있으면 수정 후 기존 기능이 정상 동작하는지 즉시 확인 가능
- **예외 상황 처리**: API 실패, 토큰 만료, 경계값 등 예외 케이스를 체계적으로 발견하고 처리
- **리팩토링 안전장치**: 15라인 초과 함수를 분리할 때 기존 동작 유지 검증
- **SRP 검증**: 비즈니스/UI 로직 분리를 테스트를 통해 확인
- **문서화 역할**: 테스트 케이스가 함수의 입출력과 예외 상황을 설명하는 "살아있는 문서"

### 구현 단계

| 단계 | 내용 | 상태 |
|------|------|------|
| 1 | 테스트 환경 설정 (Jest, RTL, MSW) | 완료 |
| 2 | 유틸 함수 테스트 | 완료 |
| 3 | Zustand 스토어 테스트 | 완료 |
| 4 | 커스텀 훅 테스트 | 완료 |
| 5 | API 레이어 테스트 | 완료 |
| 6 | 컴포넌트 테스트 | 완료 |
| 7 | E2E 테스트 (Cypress) | 완료 |
| 8 | 코드 품질 개선 | 완료 |

### 구현 결과

| 항목 | 시작 | 최종 | 변화 |
|------|------|------|------|
| 테스트 커버리지 | 5.2% | **90.19%** | +84.99% |
| Test Suites | 5 | 107 | +102 |
| Tests | 23 | 872 | +849 |

**테스트 현황:**
- 유틸 함수: 95%+
- Zustand 스토어: 100%
- 커스텀 훅: 90%+
- API 레이어: 90%+
- 컴포넌트: 85%+

### 기술 스택

| 도구 | 용도 | 버전 |
|------|------|------|
| Jest | 테스트 러너 | 30.x |
| React Testing Library | 컴포넌트 테스트 | 16.x |
| MSW | API 모킹 | 2.x |
| Cypress | E2E 테스트 | 13.x |

### 프리코스 피드백 적용

- 예외 상황 고려 및 테스트
- 함수 15라인 제한
- 비즈니스/UI 로직 분리 (SRP)
- 상수 사용 (하드코딩 제거)
- 테스트 코드도 코드다 (리팩토링, test.each 활용)
- E2E 테스트로 요구사항 검증

<br>

---

## 2. 상태 분석 시각화 도구

### 문제 정의

현재 프론트엔드 개발에서 가장 불편하다고 느끼는 문제는 **전역 상태 관리에 대한 오해**와 그로 인한 구조적 복잡도이다.

Context API, Zustand, Jotai 같은 도구들이 모두 "전역 상태 관리"로 분류되지만, 실제로는 방향과 동작 방식이 완전히 다르다. 그럼에도 현장에서는 "전역 상태가 필요하다"는 이유로 도구를 선택하는 경우가 많고, 기준이 패러다임보다는 단순히 "전역으로 사용할 수 있는가"에 맞춰지는 일이 잦다.

**주요 문제점:**
- Context는 리액트 트리 내부에서 데이터를 전달하는 메커니즘 (의존성 주입)
- Zustand/Jotai는 리액트 외부에서 독립적인 상태를 관리 (외부 스토어)
- 이 구분이 명확하지 않으면 불필요한 전역 상태 의존이 생김
- 상태 변경의 원인을 추적하기 어려워짐
- 리렌더링 범위가 불필요하게 넓어져 성능 저하
- 테스트 작성이 어려워지고 컴포넌트 재사용성이 떨어짐

### 해결 접근 방식

**상태의 위치와 책임을 판단할 기준을 제공하는 분석 도구 개발**

1. AST 파싱으로 상태 훅 사용 위치 추출
2. 컴포넌트 트리에서 상태 사용 분포 분석
3. Context vs 외부 스토어 적합성 제안
4. 웹 시각화로 결과 표시

### 구현 단계

| 단계 | 내용 | 상태 |
|------|------|------|
| 1 | CLI 분석 도구 구현 (ts-morph) | 완료 |
| 2 | 분석 결과 JSON 생성 | 완료 |
| 3 | 시각화 컴포넌트 구현 | 완료 |
| 4 | 블로그에 분석 페이지 추가 | 완료 |
| 5 | Three.js 파티클 배경 추가 | 완료 |

### 구현 결과

**시각화 차트:**
- 상태 타입 비율 (Pie Chart)
- 상태 타입별 사용량 (Bar Chart)
- 컴포넌트 × 상태 타입 매트릭스 (HeatMap)
- Top 10 컴포넌트 상태 사용량 (Horizontal Bar)

**분석 기능:**
- 총 컴포넌트 수, 상태 사용량 요약
- useState, Zustand, Context 사용 현황
- 컴포넌트별 상세 정보
- 개선 제안 (과도한 상태 사용 경고)

### 기술 스택

| 도구 | 용도 | 버전 |
|------|------|------|
| ts-morph | AST 파싱 | 24.x |
| Nivo | 차트 라이브러리 | 0.99.x |
| Three.js | 3D 파티클 배경 | 0.176.x |

### 컴포넌트 구조

```
src/components/analysis/
├── AnalysisState.tsx (메인)
├── AnalysisParticleBackground.tsx
├── AnalysisPieChart.tsx
├── AnalysisBarChart.tsx
├── AnalysisHeatMap.tsx
├── AnalysisTopComponents.tsx
├── AnalysisSuggestionItem.tsx
└── AnalysisComponentItem.tsx
```

<br>

---

## 3. 애니메이션/인터랙션 시스템

### 문제 정의

사용자 경험은 주관적인 영역이지만, 현재 블로그는 인터랙션 피드백이 부족하다. 사용자가 버튼을 클릭하거나 페이지를 이동할 때 즉각적인 변화만 일어나면 "내 행동이 반영되었는지" 확신하기 어렵다. 또한 콘텐츠가 갑자기 나타나거나 사라지면 시각적 맥락이 끊어져 혼란을 느낄 수 있다.

이러한 문제를 개선하기 위해 체계적인 애니메이션/인터랙션 시스템을 구축하려고 한다.

**주요 문제점:**
- 페이지 전환 시 즉각적인 교체로 시각적 맥락 단절
- 버튼, 카드 등의 호버/클릭 피드백 부재로 인터랙션 확인 어려움
- 스크롤 기반 애니메이션 없어 콘텐츠 발견의 즐거움 부족
- 로딩 상태의 시각적 표현 부족으로 대기 시간이 길게 느껴짐
- 일관성 없는 애니메이션으로 브랜드 정체성 약화

### 해결 접근 방식

**재사용 가능한 애니메이션 시스템 구축**

1. Framer Motion 기반 애니메이션 훅 개발
2. 공통 전환 효과 컴포넌트 구현
3. 스크롤 기반 애니메이션 시스템
4. 마이크로 인터랙션 라이브러리

### 구현 단계

| 단계 | 내용 | 상태 |
|------|------|------|
| 1 | 페이지 전환 애니메이션 구현 | 완료 |
| 2 | 스크롤 진행 표시기 구현 | 완료 |
| 3 | 애니메이션 훅 개발 | 완료 |
| 4 | 컴포넌트 호버/클릭 효과 | 완료 |
| 5 | Layout 통합 및 최적화 | 완료 |

### 구현 결과

**페이지 전환 애니메이션:**
- `PageTransition` 컴포넌트로 fade/slide 효과
- React Router의 location 변경 감지
- 150ms 트랜지션으로 부드러운 전환

**스크롤 진행 표시기:**
- `ScrollProgress` 컴포넌트
- 상단 고정 프로그레스 바
- 그라데이션 색상 (indigo → purple → pink)

**애니메이션 훅:**
- `useScrollProgress`: 스크롤 진행률 추적
- `usePageTransition`: 페이지 전환 상태 관리

### 기술 스택

| 도구 | 용도 |
|------|------|
| Tailwind CSS | 트랜지션 및 애니메이션 |
| React Router | 페이지 전환 감지 |

### 컴포넌트 구조

```
src/components/common/
├── PageTransition/
│   └── PageTransition.tsx
└── ScrollProgress/
    └── ScrollProgress.tsx

src/hooks/animation/
├── useScrollProgress.ts
└── usePageTransition.ts
```

### 프리코스 피드백 적용

- 사용자 경험 개선을 위한 시각적 피드백
- 재사용 가능한 컴포넌트 설계
- 성능을 고려한 passive 이벤트 리스너
- 컴포넌트 분리 및 단일 책임 원칙
